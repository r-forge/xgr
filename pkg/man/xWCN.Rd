% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/xWCN.r
\name{xWCN}
\alias{xWCN}
\title{Function to perform weighted gene correlated network analysis}
\usage{
xWCN(data, networkType = c("unsigned", "signed", "signed hybrid"),
powerVector = 1:25, setBeta = "wgcna", RsquaredCut = 0.85,
TOMType = c("signed", "unsigned"), minClusterSize = 30,
deepSplit = c(2, 1, 0, 3, 4), merge = T, cutHeight = 0.2,
verbose = T)
}
\arguments{
\item{data}{a data matrix or data frame. It can be an expresison-like
matrix (with rows for genes and columns for samples) or a similarity
matrix (symmetric)}

\item{networkType}{network type. It determines how the adajcency [0,1]
is transformed from correlations ([-1,1]), resulting in a weighted
network adjacency matrix. It can be one of "unsigned" (|cor|^power),
"signed" ((0.5*(1+cor))^power), and "signed hybrid" (cor^power if cor>0
and 0 otherwise)}

\item{powerVector}{a vector of soft thresholding powers for which the
scale-free topology fit indices are to be calculated}

\item{setBeta}{NULL or "wgcna" or an integer. If NULL, beta will be
determined internally; if "wgcna", estimate of an appropriate
soft-thresholding power is the lowest power for which the scale free
topology fit R^2 exceeds "RsquaredCut". It can be specified explicitly
by the beta value (an integer)}

\item{RsquaredCut}{desired minimum scale free topology fitting index
R^2}

\item{TOMType}{TOM type. It determines what will be used as inputs. It
can be one of "unsigned" (taking as inputs the adjacency), "signed"
(taking as inputs the adjacency multiplied by the sign of the
adjacency)}

\item{minClusterSize}{minimum cluster size}

\item{deepSplit}{an integer [0,4] controlling sensitivity to cluster
splitting. The higher the value, the more and smaller clusters will be
produced}

\item{merge}{logical to indicate whether to merge close modules
(measured by the eigengene correlation). It only works when input data
is expression-like matrix}

\item{cutHeight}{maximum dissimilarity (1-cor) that qualifies modules
for merging}

\item{verbose}{logical to indicate whether the messages will be
displayed in the screen. By default, it sets to true for display}
}
\value{
an object of class "cModule", a list with following components:
\itemize{
\item{\code{mem}: a data frame of n X 3 containing module membership
information, where n is the number of nodes, and the 3 columns are
"nodes", "modules" (an integer), "rank" (intramodule hub rank)}
\item{\code{expr}: an input data for nodes assigned to modules}
\item{\code{adj}: a weighted network adjacency matrix}
\item{\code{io}: a named list containing inputs/outputs associated,
including input paramters
("inputType","networkType","TOMType","minClusterSize"), and output
results
("beta","r2","fit","num_modules","pattern_modules","gp_fit","tree")}
\item{\code{call}: the call that produced this result}
}
}
\description{
\code{xWCN} is supposed to perform weighted gene correlated network
analysis. It returns an object of class "cModule".
}
\note{
none
}
\examples{
\dontrun{
# Load the library
library(XGR)
RData.location <- "http://galahad.well.ox.ac.uk/bigdata/"

cModule <- xWCN(data, merge=T)
head(cModule$mem)
names(cModule$io)

# Enrichment analysis of modular genes: using REACTOME pathways
ls_eTerm <- xEnricherGenesAdv(cModule, background=cModule$mem$nodes,
ontologies=c("REACTOME"), size.range=c(10,500), test="fisher",
min.overlap=10, p.tail="one-tail", RData.location=RData.location,
plot=T, fdr.cutoff=0.05, displayBy="zscore")
gp <- xEnrichForest(ls_eTerm, top_num=5, CI.one=F, FDR.cutoff=0.05,
signature=F, drop=T, colormap="yellow-red")

# Network analysis of modular genes: intramodular genes in an interaction network
# 1) define netowrk to visualise
g <- xDefineNet(network="STRING_high",
STRING.only=c("experimental_score","database_score"),
RData.location=RData.location)
# 2) genes/nodes in module 2
nodes_query <- (cModule$mem \%>\% dplyr::filter(modules==2))$nodes
# 3) connectivity of intramodular genes in the interaction network
ig <- dnet::dNetInduce(g, nodes_query=nodes_query, knn=0,
largest.comp=F)
# 4) visualisation
ig <- xLayout(ig, layout="gplot.layout.fruchtermanreingold")
gp <- xGGnetwork(ig, node.xcoord="xcoord", node.ycoord="ycoord",
node.color.alpha=0.5, edge.color.alpha=0.2)
## also size by degree
V(ig)$degree <- igraph::degree(ig)
gp <- xGGnetwork(ig, node.xcoord="xcoord", node.ycoord="ycoord",
node.color.alpha=0.5, edge.color.alpha=0.2, node.size="degree",
node.size.range=c(1,5))
## also label by intramodule hub genes (top 10)
ind <- match(V(ig)$name,cModule$mem$nodes)
V(ig)$rank <- cModule$mem$rank[ind]
V(ig)$label <- ''
V(ig)$label[V(ig)$rank<=10] <- V(ig)$name[V(ig)$rank<=10]
gp <- xGGnetwork(ig, node.xcoord="xcoord", node.ycoord="ycoord",
node.color.alpha=0.5, edge.color.alpha=0.2, node.size="degree",
node.size.range=c(1,5), node.label="label", node.label.size=2,
node.label.force=0.01)

# Visualisation of the tree dendrogram (without merging similar modules)
cModule <- xWCN(data, merge=F)
## extract the tree info (dend, tips, mat)
dend <- cModule$io$tree$dend
tips <- cModule$io$tree$tips
mat <- cModule$io$tree$mat
## color tree branches by modules
cols <- xColormap("ggplot2")(length(unique(tips$modules)) - 1)
dend2 <- dend \%>\% dendextend::branches_attr_by_clusters(tips$modules,
values=cols[unique(tips$modules)]) \%>\% dendextend::set("labels_cex",
c(.5,0.5))
plot(dend2, type="rectangle", leaflab='none')
## using circlize
dendextend::circlize_dendrogram(dend2)
## using ggplot
ggd <- dendextend::as.ggdend(dend2)
gp <- ggplot(ggd, horiz=T)
gp <- ggplot(ggd, labels=F) + scale_y_reverse(expand=c(0.2,0)) +
coord_polar(theta="x")
## using gplots (heatmap)
allcols <- c('black',cols)
### RowSideColors (ordered by data)
ind <- match(rownames(data), tips$nodes)
RowSideColors <- allcols[tips$modules[ind] + 1]
gplots::heatmap.2(as.matrix(data), dendrogram="row", Rowv=dend2,
Colv=T, col=xColormap('spectral'), trace="none", labRow=NA, labCol=NA,
srtCol=20, RowSideColors=RowSideColors)
## using ggtree
tree <- ape::as.phylo(as.hclust(dend))
membership <- subset(tips, modules!=0)[,2]
names(membership) <- subset(tips, modules!=0)[,1]
### rectangular layout
gp <- xGGtree(tree, membership, layout="rectangular")
gp + ggtree::geom_tiplab(size=1)
gp$tree
gp$tree$cluster
### fan layout
gp <- xGGtree(tree, membership, layout="fan")
gp + ggtree::geom_tiplab2(size=1)
}
}
\seealso{
\code{\link{xWCN}}
}
